<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>
<#@ parameter type="System.Int32" name="MaxCount" #>
// <auto-generated />
using System.Runtime.CompilerServices;

namespace Macaron.Functional;

partial class Utility
{
<#
    for (var paramCount = 2; paramCount <= MaxCount; paramCount++)
    {
        GeneratePartialApplicationMethods(paramCount);
    }
#>
}
<#+
private void GeneratePartialApplicationMethods(int paramCount)
{
    for (var fixedArgumentCount = 1; fixedArgumentCount < paramCount; ++fixedArgumentCount)
    {
        GenerateRecursively(fixedArgumentStates: new bool[paramCount], index: 0, count: 0, fixedArgumentCount);
    }
}

private void GenerateRecursively(bool[] fixedArgumentStates, int index, int count, int fixedArgumentCount)
{
    while (true)
    {
        if (count == fixedArgumentCount)
        {
            GenerateMethod(fixedArgumentStates);
            return;
        }

        if (index >= fixedArgumentStates.Length)
        {
            return;
        }

        fixedArgumentStates[index] = true;
        GenerateRecursively(fixedArgumentStates, index: index + 1, count: count + 1, fixedArgumentCount);
        fixedArgumentStates[index] = false;

        index += 1;
    }
}

private void GenerateMethod(IReadOnlyList<bool> fixedArgumentStates)
{
    var paramCount = fixedArgumentStates.Count;

    var funcParameters = new List<string>();
    var returnTypeParams = new List<string>();
    var lambdaInputParams = new List<string>();
    var lambdaArgs = new List<string>();

    var useDefaultPlaceHolderValue = true;
    var seenPlaceholder = false;

    for (var i = 0; i < fixedArgumentStates.Count; i++)
    {
        if (seenPlaceholder)
        {
            if (fixedArgumentStates[i])
            {
                useDefaultPlaceHolderValue = false;
                break;
            }
        }
        else if (!fixedArgumentStates[i])
        {
            seenPlaceholder = true;
        }
    }

    for (var i = 0; i < paramCount; i++)
    {
        var paramIndex = i + 1;
        if (fixedArgumentStates[i])
        {
            funcParameters.Add($"T{paramIndex} arg{paramIndex}");
            lambdaArgs.Add($"arg{paramIndex}");
        }
        else
        {
            funcParameters.Add($"Placeholder _{paramIndex}{(useDefaultPlaceHolderValue ? " = default" : "")}");
            returnTypeParams.Add($"T{paramIndex}");
            lambdaInputParams.Add($"arg{paramIndex}");
            lambdaArgs.Add($"arg{paramIndex}");
        }
    }

    var typeParams = string.Join(", ", Enumerable.Range(1, paramCount).Select(i => $"T{i}"));
    var funcReturnType = returnTypeParams.Count > 0
        ? $"Func<{string.Join(", ", returnTypeParams)}, TResult>"
        : "Func<TResult>";
    var actionReturnType = returnTypeParams.Count > 0
        ? $"Action<{string.Join(", ", returnTypeParams)}>"
        : "Action";
#>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= funcReturnType #> Partial<<#= typeParams + ", TResult" #>>(
        Func<<#= typeParams #>, TResult> fn,
        <#= string.Join($",{Environment.NewLine}        ", funcParameters) #>
    )
    {
<#+
    if (returnTypeParams.Count > 0)
    {
#>
        return (<#= string.Join(", ", lambdaInputParams) #>) => fn(<#= string.Join(", ", lambdaArgs) #>);
<#+
    }
    else
    {
#>
        return () => fn(<#= string.Join(", ", lambdaArgs) #>);
<#+
    }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static <#= actionReturnType #> Partial<<#= typeParams #>>(
        Action<<#= typeParams #>> fn,
        <#= string.Join($",{Environment.NewLine}        ", funcParameters) #>
    )
    {
<#+
    if (returnTypeParams.Count > 0)
    {
#>
        return (<#= string.Join(", ", lambdaInputParams) #>) => fn(<#= string.Join(", ", lambdaArgs) #>);
<#+
    }
    else
    {
#>
        return () => fn(<#= string.Join(", ", lambdaArgs) #>);
<#+
    }
#>
    }

<#+
}
#>
